# Live!

This directory contains the core **live** library and components that use it.

## Overview

The **live** library provides a simple but very useful concept of reactive variables called LiveVars,
for use with React.

LiveVars can be used to wire components together without extra state or context.
Suppose you have a value generated by one component (A), perhaps from a ref attached to
a DOM element, and another component (B) needs to know when the value changes.  A third
component (C) is higher up in the tree and could serve as the single source of truth,
but ideally it would not need additional state to serve this purpose, because it
should not need to re-render.  LiveVars solve this problem by letting you make a LiveVar
the source of truth, and listening (subscribing) to value changes only in components that
use the value, and thus need to re-render when the value changes:

               +-------------------------------------------+
               | this.foo = createLiveVar(initialValue) (C)|
               +-------------------------------------------+
                             /                 \
                            /                   \
    +---------------------------+    +---------------------+
    | <Listen to={{foo}}>       |    |   foo(newValue)     |
    |   ^ re-renders on change  |    |                  (A)|
    |   { ({foo}) => ... }      |    +---------------------+
    | </Listen>              (B)|
    +---------------------------+

Context is unnecessarily heavy for this situation, especially when it comes to
defining resuable widgets and behaviors.  For example, a popover widget that uses context
to communicate the current "reference" element to the popover would need three components
to fulfill roles A, B, and C, including a "manager" component at position C to set up the
context.  If this popover widget is built on to create a dropdown widget or a hover card
widget, these widgets must also expose multiple components.

With LiveVars, a popover widget can be written that is very lightweight to include in the
calling code's components A, B, and C, and the calling code does not even need to use LiveVars:

     +-------------------------------------------------+
     | this.popover = createPopover()                  |
     | { targetReceiver, BoundPopover} = this.popover  |
     +-------------------------------------------------+
                   /                  \
                  /                    \
    +--------------------+  +-----------------------------+
    | <BoundPopover>     |  | <span ref={targetReceiver}> |
    |   ^ listens inside |  |   ... </span>               |
    | </BoundPopover>    |  +-----------------------------+
    +--------------------+

The code using the popover only needs to contend with one component, BoundPopover.  It is
much easier to combine and compose this kind of widget than one that requires the caller
to use state or a "manager" component to manage the reactive state.

## Basic API

A "receiver" is just a function that takes a value and has a void return type:

```
type Receiver<V> = (newValue: V) => void
```

A "listenable" is a value that can be listened to by a `<Listen>` component,
or you can listen to it directly using its API:

```
interface Listenable<V> {
  listen(receiver: Receiver<V>): void
  unlisten(receiver: Receiver<V>): void
  peek(): V
}
```

Note that `listen` and `unlisten` use object identity (`===`) to identify receivers.
You must pass the same function object into `unlisten` as you did to `listen`.

A LiveVar is a Receiver and a Listenable:

```
interface LiveVar<V> extends Listenable<V>, Receiver<V> {}
```

You create a LiveVar using `createLiveVar`, generally in your component's constructor:

```
width: LiveVar<number>

this.width = createLiveVar(0)
```

You set a LiveVar by calling it like a function:

```
this.width(newWidth)
```

You subscribe to a LiveVar using the `<Listen>` component, which takes an object
whose values are LiveVars, and calls the children function with the current values
of those LiveVars, while listening to changes for you:

```
<Listen to={{width: widthVar, height: heightVar}}>
  {
    ({width, height}) => <div>
      <div>Current width: {width}</div>
      <div>Current height: {height}</div>
    </div>
  }
</Listen>
```

Giving LiveVars names ending in Var becomes tedious and is not encouraged, especially
given that the type system will make sure you correctly distinguish between LiveVars
and values.  The previous example could be written to use object shorthand and
shadow the LiveVars with the values of the variables:

```
// given width and height as LiveVars
<Listen to={{width, height}}>
  {
    ({width, height}) => <div>
      <div>Current width: {width}</div>
      <div>Current height: {height}</div>
    </div>
  }
</Listen>
```

To save typing, there are "DOM" versions of the core live types that are designed for
the common case of React callback refs on DOM elements:

```
type DOMReceiver = Receiver<HTMLElement | null>
type DOMListenable = Listenable<HTMLElement | null>
type LiveDOMVar = LiveVar<HTMLElement | null>

this.element = createLiveDOMVar() // initial value defaults to null
```